// Generated by ts-to-zod
import { z } from 'zod';
import { keyBaseSchema, nameIdKeySchema, nameIdSchema, responseBaseSchema } from '../core';

export const pvpTalentIndexResponseSchema = responseBaseSchema.extend({
  pvp_talents: z.array(nameIdKeySchema),
});

export const pvpTalentResponseSchema = responseBaseSchema.extend({
  compatible_slots: z.array(z.number()),
  description: z.string(),
  id: z.number(),
  overrides_spell: nameIdKeySchema.optional(),
  playable_specialization: nameIdKeySchema,
  spell: nameIdKeySchema,
  unlock_player_level: z.number(),
});

export const talentIndexResponseSchema = responseBaseSchema.extend({
  talents: z.array(nameIdKeySchema),
});

const rankDescriptionSchema = z.strictObject({
  description: z.string().nullable(),
  rank: z.number(),
});

const talentTreeSchema = keyBaseSchema.extend({
  name: z.string(),
});

const specTalentTreeSchema = keyBaseSchema.extend({
  name: z.string(),
});

const restrictionLineSchema = z.strictObject({
  is_for_class: z.boolean(),
  required_points: z.number(),
  restricted_row: z.number(),
});

const purpleSpellTooltipSchema = z.strictObject({
  cast_time: z.string(),
  description: z.string(),
  spell: nameIdKeySchema,
});

const nodeTypeSchema = z.strictObject({
  id: z.number(),
  type: z.union([z.literal('ACTIVE'), z.literal('CHOICE'), z.literal('PASSIVE')]),
});

const choiceOfTooltipSchema = z.strictObject({
  spell_tooltip: purpleSpellTooltipSchema,
  talent: nameIdKeySchema,
});

const tooltipSpellTooltipSchema = z.strictObject({
  cast_time: z.string(),
  cooldown: z.string().optional(),
  description: z.string(),
  power_cost: z.string().optional(),
  range: z.string().optional(),
  spell: nameIdKeySchema,
});

export const talentResponseSchema = responseBaseSchema.extend({
  id: z.number(),
  overrides_spell: nameIdKeySchema.optional(),
  playable_class: keyBaseSchema
    .and(
      z.strictObject({
        id: z.number(),
        name: z.string().optional(),
      }),
    )
    .optional(),
  playable_specialization: nameIdKeySchema.optional(),
  rank_descriptions: z.array(rankDescriptionSchema).optional(),
  spell: nameIdKeySchema.optional(),
});

export const talentTreeIndexResponseSchema = responseBaseSchema.extend({
  class_talent_trees: z.array(talentTreeSchema),
  hero_talent_trees: z.array(nameIdKeySchema),
  spec_talent_trees: z.array(talentTreeSchema),
});

const tooltipSchema = z.strictObject({
  spell_tooltip: tooltipSpellTooltipSchema,
  talent: nameIdKeySchema,
});

const rankSchema = z.strictObject({
  choice_of_tooltips: z.array(tooltipSchema).optional(),
  default_points: z.number().optional(),
  rank: z.number(),
  tooltip: tooltipSchema.optional(),
});

const specTalentNodeRankSchema = z.strictObject({
  choice_of_tooltips: z.array(choiceOfTooltipSchema).optional(),
  rank: z.number(),
  tooltip: tooltipSchema.optional(),
});

const talentNodeSchema = z.strictObject({
  display_col: z.number(),
  display_row: z.number(),
  id: z.number(),
  locked_by: z.array(z.number()).optional(),
  node_type: nodeTypeSchema,
  ranks: z.array(rankSchema),
  raw_position_x: z.number(),
  raw_position_y: z.number(),
  unlocks: z.array(z.number()).optional(),
});

export const talentTreeNodesResponseSchema = responseBaseSchema.extend({
  id: z.number(),
  spec_talent_trees: z.array(specTalentTreeSchema),
  talent_nodes: z.array(talentNodeSchema),
});

const specTalentNodeSchema = z.strictObject({
  display_col: z.number(),
  display_row: z.number(),
  id: z.number(),
  locked_by: z.array(z.number()).optional(),
  node_type: nodeTypeSchema,
  ranks: z.array(specTalentNodeRankSchema),
  raw_position_x: z.number(),
  raw_position_y: z.number(),
  unlocks: z.array(z.number()).optional(),
});

const classTalentNodeRankSchema = z.strictObject({
  choice_of_tooltips: z.array(tooltipSchema).optional(),
  default_points: z.number().optional(),
  rank: z.number(),
  tooltip: tooltipSchema.optional(),
});

const heroTalentTreeNodeSchema = z.strictObject({
  display_col: z.number(),
  display_row: z.number(),
  id: z.number(),
  locked_by: z.array(z.number()).optional(),
  node_type: z.strictObject({
    id: z.number(),
    type: z.union([z.literal('ACTIVE'), z.literal('CHOICE'), z.literal('PASSIVE')]),
  }),
  ranks: z.array(rankSchema),
  raw_position_x: z.number(),
  raw_position_y: z.number(),
  unlocks: z.array(z.number()).optional(),
});

const classTalentNodeSchema = z.strictObject({
  display_col: z.number(),
  display_row: z.number(),
  id: z.number(),
  locked_by: z.array(z.number()).optional(),
  node_type: nodeTypeSchema,
  ranks: z.array(classTalentNodeRankSchema),
  raw_position_x: z.number(),
  raw_position_y: z.number(),
  unlocks: z.array(z.number()).optional(),
});

const heroTalentTreeSchema = nameIdSchema.extend({
  hero_talent_nodes: z.array(heroTalentTreeNodeSchema),
  media: keyBaseSchema.and(
    z.strictObject({
      id: z.number(),
    }),
  ),
  playable_class: nameIdKeySchema,
  playable_specializations: z.array(nameIdKeySchema),
});

export const talentTreeResponseSchema = nameIdSchema.extend(responseBaseSchema.shape).extend({
  class_talent_nodes: z.array(classTalentNodeSchema),
  hero_talent_trees: z.array(heroTalentTreeSchema),
  media: keyBaseSchema,
  playable_class: nameIdKeySchema,
  playable_specialization: nameIdKeySchema,
  restriction_lines: z.array(restrictionLineSchema),
  spec_talent_nodes: z.array(specTalentNodeSchema),
});
